<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on Computable(verse)</title>
    <link>http://computableverse.com/tags/nginx/index.xml</link>
    <description>Recent content in Nginx on Computable(verse)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://computableverse.com/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fix Django Invalid HTTP_HOST header emails</title>
      <link>http://computableverse.com/blog/2017-02-26-django-invalid-http-host-header/</link>
      <pubDate>Sun, 26 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/2017-02-26-django-invalid-http-host-header/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a long time since I deployed a django application on the internet. At
first, I had no idea about the features of Django and was running it just like
any other flask app. But soon, I came across the  wonderful &lt;strong&gt;Error Reporting&lt;/strong&gt;
module and I quickly realised how I had been missing something like this in my
Flask deployments.&lt;/p&gt;

&lt;p&gt;But soon, I started getting a TON of &lt;code&gt;Invalid HTTP_HOST header&lt;/code&gt;. I tried to
take a look into what exactly what happening.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://computableverse.com/assets/images/django-errors.png&#34; alt=&#34;tons of invalid host errors&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Firstly, I have a couple sites hosted on my server. Some of them are served via
&lt;code&gt;https&lt;/code&gt; and some aren&amp;rsquo;t. When I took a closer look into the error reports, I
could see that none of them had a &lt;em&gt;request url&lt;/em&gt; of earthlyhumans.com (my django
app). They had the request of one of my other websites, but it somehow wasn&amp;rsquo;t
being caught by their nginx configs.&lt;/p&gt;

&lt;p&gt;So I took a look into how nginx choses a configuration for a particular
request. First, it will check if a particular config has a valid &lt;code&gt;listen&lt;/code&gt;
directive for the incoming request. If it does, then it moves onto checking the
&lt;code&gt;server_name&lt;/code&gt; directive. If neither happens, it redirects to the &lt;code&gt;default&lt;/code&gt;
block.&lt;/p&gt;

&lt;p&gt;I already had a default block configured as follows..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    return 444;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and yet urls were getting passed onto my Django application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/nginx/sites-available$ tree
.
|-- default
|-- earthlyhumans.com.conf
|-- example.com.conf
`-- example2.com.conf

0 directories, 4 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how my configuration looked. Now the problem was that why weren&amp;rsquo;t the
requests getting redirected to one of my other applications.&lt;/p&gt;

&lt;p&gt;Turns out, the &amp;ldquo;default&amp;rdquo; server in nginx is the first server block it reads i.e
sorted alphabetically, unless you have the &lt;code&gt;default_server&lt;/code&gt; option listed in
the &lt;code&gt;listen&lt;/code&gt; directive.&lt;/p&gt;

&lt;p&gt;But wait a minute, &lt;code&gt;default&lt;/code&gt; block is still the first listed server block. But
silly me, I hadn&amp;rsquo;t added a listen block for port 443. So it went ahead and
found the first block with port 443 and matched it with my django server block.&lt;/p&gt;

&lt;p&gt;So I simply changed my default config to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80 default_server;
    return 444;
}

server {
    listen 443 default_server;
    server_name _; # This can be omitted.
    return 444;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;special nginxâ€™s non-standard code 444 is returned that closes the connection.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That seemed to have fixed all my issues. You can also explicitly rename &lt;code&gt;default&lt;/code&gt;
file to something like &lt;code&gt;0000-default&lt;/code&gt; which makes sure that it&amp;rsquo;s the first
config to be loaded.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/http/request_processing.html&#34;&gt;nginx request processing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/beginners_guide.html&#34;&gt;nginx beginners guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- date: 2016-08-25 --&gt;</description>
    </item>
    
    <item>
      <title>Autoindex with try_files in nginx</title>
      <link>http://computableverse.com/blog/nginx-autoindex-try-files/</link>
      <pubDate>Thu, 26 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/nginx-autoindex-try-files/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s a bit nitpicky but after setting up a couple of websites,
I always run across this issue and have to randomly guess and
try until I get it right. So let&amp;rsquo;s change that and understand
the proper way to implement nginx with both &lt;code&gt;try_files&lt;/code&gt;
directive and automatic directory index using &lt;code&gt;autoindex on&lt;/code&gt;
with a working 404 page on incorrect urls.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have a particular location block in which we want
these features to co-exist. What we need is something like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Match uri exactly&lt;/li&gt;
&lt;li&gt;Show &lt;code&gt;index.html&lt;/code&gt; if it is present&lt;/li&gt;
&lt;li&gt;Show &lt;code&gt;{uri}.html&lt;/code&gt; if it is present&lt;/li&gt;
&lt;li&gt;Show an automated directory if folder exists&lt;/li&gt;
&lt;li&gt;Otherwise show a 404 error&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;2nd point is implemented using an inbuilt nginx directive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rest of the scenarios are implemented using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try_files $uri $uri.html $uri/ =404;
autoindex on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are checked in order until one of the condition satisfies.&lt;/p&gt;

&lt;p&gt;Entire config:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    server_name rogue.oxal.org;
    server_tokens off;
    root /var/www/rogue.oxal.org/public;
    index index.html;

    location / {
        autoindex on;
        try_files $uri $uri.html $uri/ =404;
    }

    error_page 404 /404.html;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Implement HTTPS using SSL/TLS for FREE within 5 minutes</title>
      <link>http://computableverse.com/blog/implement-https-using-ssl-tls-free-fast/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/implement-https-using-ssl-tls-free-fast/</guid>
      <description>&lt;p&gt;I reckon I&amp;rsquo;ll need to set up TLS for several sites in the future. Applying the DRY principle, I&amp;rsquo;m documenting the steps while it&amp;rsquo;s fresh in my head, so that I don&amp;rsquo;t have to waste time 10 months down the line.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s keep this short and useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;install-letsencrypt&#34;&gt;Install letsencrypt&lt;/h3&gt;

&lt;p&gt;No wizardry here. Simple as sh. Refer this &lt;a href=&#34;https://www.nginx.com/blog/free-certificates-lets-encrypt-and-nginx/&#34;&gt;guide&lt;/a&gt; for more details.&lt;/p&gt;
sudo git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt
cd /opt/letsencrypt
sudo ./letsencrypt-auto
cd /var/www
mkdir letsencrypt
sudo chgrp www-data letsencrypt

&lt;h3 id=&#34;set-up-letsencrypt-config-file-and-fetch-certificates&#34;&gt;Set up letsencrypt config file and fetch certificates&lt;/h3&gt;

&lt;p&gt;More info &lt;a href=&#34;https://gist.github.com/xrstf/581981008b6be0d2224f&#34;&gt;here&lt;/a&gt;, but siriusly no need to get too involved. Just run the below script as follows &lt;code&gt;sh setupLEConfig.sh &amp;lt;your-domain-name-here&amp;gt; &amp;lt;your-email-here&amp;gt;&lt;/code&gt;:&lt;/p&gt;
#!/bin/bash

cat &lt;&lt;EOF &gt; /etc/letsencrypt/configs/$1.conf
domains = $1
rsa-key-size = 4096

# the current closed beta (as of 2015-Nov-07) is using this server
server = https://acme-v01.api.letsencrypt.org/directory

# this address will receive renewal reminders
email = $2

# turn off the ncurses UI, we want this to be run as a cronjob
text = True

# authenticate by placing a file in the webroot (under .well-known/acme-challenge/)
# and then letting LE fetch it
authenticator = webroot
webroot-path = /var/www/letsencrypt/
EOF

&lt;h3 id=&#34;fetch-certifcates-and-verify&#34;&gt;Fetch certifcates and verify&lt;/h3&gt;

&lt;p&gt;Point CA (certificate authority) where to find temporary files used for authenticating that you own the domain.&lt;/p&gt;
server {
    listen 80;
    server_name mitesh.ninja;

    # This block is important
    location /.well-known/acme-challenge {
        root /var/www/letsencrypt;
    }
}

&lt;p&gt;Now restart nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nginx -t &amp;amp;&amp;amp; sudo nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and actually fetch the certs:&lt;/p&gt;
cd /opt/letsencrypt
./letsencrypt-auto --config /etc/letsencrypt/configs/mitesh.ninja.conf certonly

&lt;h3 id=&#34;final-nginx-config-for-https&#34;&gt;Final nginx config for https&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Listen on port 443 (for ssl).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tell nginx where to find your certificates.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tell CA (certificate authority) where to find temporary files used for authenticating that you own the domain.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;We did this in http server block for first time authentication.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;https server block for authentication henceforth.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rewrite http traffic to https.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
server {
    ###
    # Replace &#39;mitesh.ninja&#39; with your own FQDN.
    ##
    listen 443 ssl; # Step 1
    server_name mitesh.ninja;

    # Step 2
    ssl_certificate /etc/letsencrypt/live/mitesh.ninja/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mitesh.ninja/privkey.pem;

    # Step 3
    location /.well-known/acme-challenge {
        root /var/www/letsencrypt;
    }
}
server {
    listen 80;
    server_name mitesh.ninja www.mitesh.ninja;
    return 301 https://$host$request_uri;
}

&lt;p&gt;Now restart nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nginx -t &amp;amp;&amp;amp; sudo nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;VOILA!&lt;/strong&gt; That&amp;rsquo;s it. https live at &lt;a href=&#34;https://mitesh.ninja&#34;&gt;https://mitesh.ninja&lt;/a&gt;. View full nginx conf &lt;a href=&#34;https://github.com/MiteshNinja/mitesh.ninja/blob/master/conf/mitesh.ninja.conf&#34;&gt;here&lt;/a&gt; :D)&lt;/p&gt;

&lt;p&gt;Note: The certificates will expire every 3 months. I haven&amp;rsquo;t set up a cron job atm. I&amp;rsquo;m researching more about it, trying new stuff and will most likely roll up a small python script to handle auto renewing.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>