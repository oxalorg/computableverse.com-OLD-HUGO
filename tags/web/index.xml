<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on Computable(verse)</title>
    <link>http://computableverse.com/tags/web/index.xml</link>
    <description>Recent content in Web on Computable(verse)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://computableverse.com/tags/web/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Secure flask-admin using flask-basicauth</title>
      <link>http://computableverse.com/blog/flask-admin-using-basicauth/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/flask-admin-using-basicauth/</guid>
      <description>&lt;p&gt;I could not find a way to protect my flask-admin installation at &lt;code&gt;/admin&lt;/code&gt; using &lt;code&gt;Flask-BasicAuth&lt;/code&gt;, so I decided to write this for future explorers!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The flask-admin docs praise the simplicity and awesomeness of using HTTP basic authentication, and also point the user towards a small extenstion which makes this easy process even easier.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The simplest form of authentication is HTTP Basic Auth. It doesn’t interfere with your database models, and it doesn’t require you to write any new view logic or template code.
Have a look at Flask-BasicAuth to see just how easy it is to put your whole application behind HTTP Basic Auth.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and then they drop the bomb saying:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unfortunately, there is no easy way of applying HTTP Basic Auth just to your admin interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oh well. I definitely do not want people to log in when they land on my index page, so that rules the above option out.&lt;/p&gt;

&lt;p&gt;Thankfully, it&amp;rsquo;s rather quite easy to extend admin views to support &lt;code&gt;flask-BasicAuth&lt;/code&gt;. We just need to override two functions in our admin &lt;code&gt;ModelView&lt;/code&gt; class.&lt;/p&gt;
class ModelView(sqla.ModelView):
    def is_accessible(self):
        if not basic_auth.authenticate():
            raise AuthException(&#39;Not authenticated.&#39;)
        else:
            return True

    def inaccessible_callback(self, name, **kwargs):
        return redirect(basic_auth.challenge())

&lt;p&gt;Here &lt;code&gt;basic_auth&lt;/code&gt; is defined as &lt;code&gt;basic_auth = BasicAuth(app)&lt;/code&gt; directly borrowed from the quickstart section of BasicAuth docs.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;BasicAuth&lt;/code&gt; can&amp;rsquo;t authenticate the user, it will raise an exception which inturn will call the &lt;code&gt;inaccessible_callback&lt;/code&gt; which will challenge the user to provide authentication details.&lt;/p&gt;

&lt;p&gt;The exception, &lt;code&gt;AuthException&lt;/code&gt;, is nothing but a simple &lt;code&gt;HTTPException&lt;/code&gt; provided by &lt;code&gt;werkzeug&lt;/code&gt;:&lt;/p&gt;
from werkzeug.exceptions import HTTPException

class AuthException(HTTPException):
    def __init__(self, message):
        super().__init__(message, Response(
            &#34;You could not be authenticated. Please refresh the page.&#34;, 401,
            {&#39;WWW-Authenticate&#39;: &#39;Basic realm=&#34;Login Required&#34;&#39;}
        ))

&lt;p&gt;Now we can call our admin views normally like this:&lt;/p&gt;
admin = Admin(app, name=&#39;ninjas-nest&#39;)
admin.add_view(ModelView(Post, db.session))
admin.add_view(ModelView(PostFiles, db.session))

&lt;p&gt;TADA! All the urls prefixed with &lt;code&gt;/admin&lt;/code&gt; now require authentication before you can proceed.&lt;/p&gt;

&lt;p&gt;WARNING: Please note that this is not secure on it&amp;rsquo;s own. It will send username and password without any encryption. Only use it with HTTPS (SSL/TLS). Also, this does not block ips which have a lot of failed attempts which could lead to security concerns. I will deal with this in a later post.&lt;/p&gt;

&lt;p&gt;Let me know if you have any better way of protecting only &lt;code&gt;flask-admin&lt;/code&gt; in the comments below.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implement HTTPS using SSL/TLS for FREE within 5 minutes</title>
      <link>http://computableverse.com/blog/implement-https-using-ssl-tls-free-fast/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/implement-https-using-ssl-tls-free-fast/</guid>
      <description>&lt;p&gt;I reckon I&amp;rsquo;ll need to set up TLS for several sites in the future. Applying the DRY principle, I&amp;rsquo;m documenting the steps while it&amp;rsquo;s fresh in my head, so that I don&amp;rsquo;t have to waste time 10 months down the line.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s keep this short and useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;install-letsencrypt&#34;&gt;Install letsencrypt&lt;/h3&gt;

&lt;p&gt;No wizardry here. Simple as sh. Refer this &lt;a href=&#34;https://www.nginx.com/blog/free-certificates-lets-encrypt-and-nginx/&#34;&gt;guide&lt;/a&gt; for more details.&lt;/p&gt;
sudo git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt
cd /opt/letsencrypt
sudo ./letsencrypt-auto
cd /var/www
mkdir letsencrypt
sudo chgrp www-data letsencrypt

&lt;h3 id=&#34;set-up-letsencrypt-config-file-and-fetch-certificates&#34;&gt;Set up letsencrypt config file and fetch certificates&lt;/h3&gt;

&lt;p&gt;More info &lt;a href=&#34;https://gist.github.com/xrstf/581981008b6be0d2224f&#34;&gt;here&lt;/a&gt;, but siriusly no need to get too involved. Just run the below script as follows &lt;code&gt;sh setupLEConfig.sh &amp;lt;your-domain-name-here&amp;gt; &amp;lt;your-email-here&amp;gt;&lt;/code&gt;:&lt;/p&gt;
#!/bin/bash

cat &lt;&lt;EOF &gt; /etc/letsencrypt/configs/$1.conf
domains = $1
rsa-key-size = 4096

# the current closed beta (as of 2015-Nov-07) is using this server
server = https://acme-v01.api.letsencrypt.org/directory

# this address will receive renewal reminders
email = $2

# turn off the ncurses UI, we want this to be run as a cronjob
text = True

# authenticate by placing a file in the webroot (under .well-known/acme-challenge/)
# and then letting LE fetch it
authenticator = webroot
webroot-path = /var/www/letsencrypt/
EOF

&lt;h3 id=&#34;fetch-certifcates-and-verify&#34;&gt;Fetch certifcates and verify&lt;/h3&gt;

&lt;p&gt;Point CA (certificate authority) where to find temporary files used for authenticating that you own the domain.&lt;/p&gt;
server {
    listen 80;
    server_name mitesh.ninja;

    # This block is important
    location /.well-known/acme-challenge {
        root /var/www/letsencrypt;
    }
}

&lt;p&gt;Now restart nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nginx -t &amp;amp;&amp;amp; sudo nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and actually fetch the certs:&lt;/p&gt;
cd /opt/letsencrypt
./letsencrypt-auto --config /etc/letsencrypt/configs/mitesh.ninja.conf certonly

&lt;h3 id=&#34;final-nginx-config-for-https&#34;&gt;Final nginx config for https&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Listen on port 443 (for ssl).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tell nginx where to find your certificates.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tell CA (certificate authority) where to find temporary files used for authenticating that you own the domain.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;We did this in http server block for first time authentication.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;https server block for authentication henceforth.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rewrite http traffic to https.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
server {
    ###
    # Replace &#39;mitesh.ninja&#39; with your own FQDN.
    ##
    listen 443 ssl; # Step 1
    server_name mitesh.ninja;

    # Step 2
    ssl_certificate /etc/letsencrypt/live/mitesh.ninja/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mitesh.ninja/privkey.pem;

    # Step 3
    location /.well-known/acme-challenge {
        root /var/www/letsencrypt;
    }
}
server {
    listen 80;
    server_name mitesh.ninja www.mitesh.ninja;
    return 301 https://$host$request_uri;
}

&lt;p&gt;Now restart nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nginx -t &amp;amp;&amp;amp; sudo nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;VOILA!&lt;/strong&gt; That&amp;rsquo;s it. https live at &lt;a href=&#34;https://mitesh.ninja&#34;&gt;https://mitesh.ninja&lt;/a&gt;. View full nginx conf &lt;a href=&#34;https://github.com/MiteshNinja/mitesh.ninja/blob/master/conf/mitesh.ninja.conf&#34;&gt;here&lt;/a&gt; :D)&lt;/p&gt;

&lt;p&gt;Note: The certificates will expire every 3 months. I haven&amp;rsquo;t set up a cron job atm. I&amp;rsquo;m researching more about it, trying new stuff and will most likely roll up a small python script to handle auto renewing.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>