<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flask on Computable(verse)</title>
    <link>http://computableverse.com/tags/flask/index.xml</link>
    <description>Recent content in Flask on Computable(verse)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://computableverse.com/tags/flask/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Secure flask-admin using flask-basicauth</title>
      <link>http://computableverse.com/blog/flask-admin-using-basicauth/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/flask-admin-using-basicauth/</guid>
      <description>&lt;p&gt;I could not find a way to protect my flask-admin installation at &lt;code&gt;/admin&lt;/code&gt; using &lt;code&gt;Flask-BasicAuth&lt;/code&gt;, so I decided to write this for future explorers!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The flask-admin docs praise the simplicity and awesomeness of using HTTP basic authentication, and also point the user towards a small extenstion which makes this easy process even easier.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The simplest form of authentication is HTTP Basic Auth. It doesn’t interfere with your database models, and it doesn’t require you to write any new view logic or template code.
Have a look at Flask-BasicAuth to see just how easy it is to put your whole application behind HTTP Basic Auth.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and then they drop the bomb saying:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unfortunately, there is no easy way of applying HTTP Basic Auth just to your admin interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oh well. I definitely do not want people to log in when they land on my index page, so that rules the above option out.&lt;/p&gt;

&lt;p&gt;Thankfully, it&amp;rsquo;s rather quite easy to extend admin views to support &lt;code&gt;flask-BasicAuth&lt;/code&gt;. We just need to override two functions in our admin &lt;code&gt;ModelView&lt;/code&gt; class.&lt;/p&gt;
class ModelView(sqla.ModelView):
    def is_accessible(self):
        if not basic_auth.authenticate():
            raise AuthException(&#39;Not authenticated.&#39;)
        else:
            return True

    def inaccessible_callback(self, name, **kwargs):
        return redirect(basic_auth.challenge())

&lt;p&gt;Here &lt;code&gt;basic_auth&lt;/code&gt; is defined as &lt;code&gt;basic_auth = BasicAuth(app)&lt;/code&gt; directly borrowed from the quickstart section of BasicAuth docs.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;BasicAuth&lt;/code&gt; can&amp;rsquo;t authenticate the user, it will raise an exception which inturn will call the &lt;code&gt;inaccessible_callback&lt;/code&gt; which will challenge the user to provide authentication details.&lt;/p&gt;

&lt;p&gt;The exception, &lt;code&gt;AuthException&lt;/code&gt;, is nothing but a simple &lt;code&gt;HTTPException&lt;/code&gt; provided by &lt;code&gt;werkzeug&lt;/code&gt;:&lt;/p&gt;
from werkzeug.exceptions import HTTPException

class AuthException(HTTPException):
    def __init__(self, message):
        super().__init__(message, Response(
            &#34;You could not be authenticated. Please refresh the page.&#34;, 401,
            {&#39;WWW-Authenticate&#39;: &#39;Basic realm=&#34;Login Required&#34;&#39;}
        ))

&lt;p&gt;Now we can call our admin views normally like this:&lt;/p&gt;
admin = Admin(app, name=&#39;ninjas-nest&#39;)
admin.add_view(ModelView(Post, db.session))
admin.add_view(ModelView(PostFiles, db.session))

&lt;p&gt;TADA! All the urls prefixed with &lt;code&gt;/admin&lt;/code&gt; now require authentication before you can proceed.&lt;/p&gt;

&lt;p&gt;WARNING: Please note that this is not secure on it&amp;rsquo;s own. It will send username and password without any encryption. Only use it with HTTPS (SSL/TLS). Also, this does not block ips which have a lot of failed attempts which could lead to security concerns. I will deal with this in a later post.&lt;/p&gt;

&lt;p&gt;Let me know if you have any better way of protecting only &lt;code&gt;flask-admin&lt;/code&gt; in the comments below.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cross domain execution of Python scripts using JS, jQ, AJAX.</title>
      <link>http://computableverse.com/blog/python-javascript-crossdomain-interaction/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://computableverse.com/blog/python-javascript-crossdomain-interaction/</guid>
      <description>&lt;p&gt;So I&amp;rsquo;ve been learning python scripting, and I&amp;rsquo;ve been trying to figure out a
very simple and trivial question.. how do I run my python scripts online?&lt;/p&gt;

&lt;p&gt;Not everyone will have access to a machine with python installed, neither will
everyone wish to install python just to execute scripts. So I wondered if
there was a way to run the python script on a server and obviously there is.
It&amp;rsquo;s also quite easy by using a framework like &amp;lsquo;Flask&amp;rsquo; or &amp;lsquo;Bottle&amp;rsquo; or, if you
dare, &amp;lsquo;Django&amp;rsquo;. But the problem was that they required my whole site to be
on the same domain.. but that is not what I had in mind.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I currently host my personal site &lt;a href=&#34;http://miteshshah.com&#34;&gt;miteshshah.com&lt;/a&gt;
via GitHub Pages, because it&amp;rsquo;s free and natively supports Jekyll (my static
blogging platform of choice). I wanted the input to my scripts taken from the
user/client on this website, which will then be relayed over to my server
which executes the python script with the respective inputs and relays back
the result to my page @miteshshah.com/&amp;lt;project&amp;gt;.&lt;/p&gt;

&lt;p&gt;But wait a minute.. I have absolutely no idea about web development? So I
decided to start with some simple Javascript and read this amazing introduction
by [MDN](). I then realised I need to learn jQuery, AJAX, JSON, HTML headers,
and, Python web frameworks. I was overwhelmed by the sheer amount of information
I was about to soak in the next few days. Instead I just decided to start coding.&lt;/p&gt;

&lt;p&gt;I installed flask &lt;code&gt;sudo python3 install flask&lt;/code&gt; and quickly got a basic web app
running on localhost.&lt;/p&gt;
from flask import Flask
app = Flask(__name__)
 
@app.route(&#34;/&lt;int:x&gt;-&lt;int:y&gt;&#34;)
def sum(x,y):
    return (&#34;Sum of x + y = &#34; + str(x+y))
 
if __name__ == &#39;__main__&#39;:
    app.debug = True
    app.run(host=&#34;127.0.0.1&#34;, port=8800)

&lt;p&gt;I could then go to &lt;a href=&#34;http://127.0.0.1:8800/2-3&#34;&gt;http://127.0.0.1:&lt;sup&gt;8800&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;-3&lt;/a&gt; and
I would get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sum of x + y = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I got my python script running as a webapp. I know had to find a way to get
the input for this script from the user. Like I said, I had no clue about web
development so I started looking at forms. HTML tag &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; was a very quick
and easy way to take input from the user and I quickly made a sample html file
with input form for my python script.&lt;/p&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt; test_local &lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt; Sum of two numbers:  &lt;/p&gt;
        &lt;form&gt;
            Number 1 : &lt;input type=&#34;text&#34; name=&#34;n1&#34;&gt;
            number 2 : &lt;input type=&#34;text&#34; name=&#34;n2&#34;&gt;
            &lt;input type=&#34;button&#34; value=&#34;Click&#34; onClick=&#34;&#34;&gt;
        &lt;/form&gt;
        &lt;div class=&#34;result&#34;&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;So now I could take input from the user. I somehow had to feed this input into my python script. I first tried doing it via pure javascript alone. A little bit of searching convinced me to instead use AJAX + jQuery.&lt;/p&gt;

&lt;p&gt;I came up with the following solution:&lt;/p&gt;
function testFunc (form) {
    var x = form.n1.value;
    var y = form.n2.value;
 
    $.ajax({
        type: &#39;GET&#39;,            
        slug: .0.0.1:5000/&#34;+x+&#34;-&#34;+y,
        contentType: &#39;text/plain&#39;,
        success: function(response, textStat){
            response = &#34;The total sum is&#34; + response;
                $(&#39;.result&#39;).html(response);    
            }
    });
}

&lt;p&gt;This would take the answer from my python script and insert it inside the div tag with class &amp;ldquo;.result&amp;rdquo;, atleast it would in theory.&lt;/p&gt;

&lt;p&gt;Having absolutely no knowledge about JS, jQuery or AJAX. It was hard for me to debug my own code.&lt;/p&gt;

&lt;p&gt;There was a particular error which took me quite some time to figure out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://127.0.0.1:8800/2-3. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is when I learned that my sample site was not authorised to transfer/relay data on another server/host. I fixed this by including a header to the respone in my python app.&lt;/p&gt;
@app.route(&#34;/&lt;int:x&gt;-&lt;int:y&gt;&#34;)
def sum(x, y):
  resp = make_response(str(x + y))
  resp.headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;*&#39;
  return resp

&lt;p&gt;I included some more CORS code in jQuery/ajax function, but I don&amp;rsquo;t quite understand it completely.&lt;/p&gt;

&lt;p&gt;The final result can be seen here: &lt;a href=&#34;http://miteshshah.com/sample&#34;&gt;http://miteshshah.com/sample&lt;/a&gt;.  [EDIT: I&amp;rsquo;ve taken this down, but you should still try this on your own. It works :P]&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>